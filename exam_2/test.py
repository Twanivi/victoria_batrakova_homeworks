# Тест:
# 1) Что такое функция и как ее объявить?
#
    Это именованный блок кода, к которому можно обратиться из любого места программы.
    У функции есть имя и список входных параметров, а также возвращаемое значение.
    Функция позволяет использовать в программе один и тот же фрагмент кода несколько раз.

    Объявление функции:
def имя_функции(параметры):
    # тело функции

    return

# 2) Как создать функцию?

    Для создания функции в Python используется ключевое слово def, за которым следует имя функции и круглые скобки ().
    В скобках указываются аргументы функции (если они есть), а после скобок ставится двоеточие :.
    Тело функции записывается с отступом.

    Пример простой функции без аргументов:
def greet():
    print('Hello world')

# 3) Как показать что созданная функция возвращает результат?

    Функции могут передавать какие-либо данные из своих тел в основную ветку программы, т.е. возвращают значение.
    Выход из функции и передача данных в то место, откуда она была вызвана, выполняется оператором return.
    Если Python, выполняя тело функции, встречает return, то он "забирает" значение, указанное после этой команды,
    и "уходит" из функции.

    Пример:
def add(a, b):
    return a + b

# 4) В чем разница между параметрами и аргументами функции?

    Параметры представляют собой переменные, которым присваиваются значения в момент вызова функции.
    Конкретные значения, которые передаются в функцию при ее вызове, называются аргументами
    Когда функция вызывается, ей передаются аргументы. Когда Python переходит к функции,
    чтобы начать ее исполнение, он присваивает переменным-параметрам переданные в функцию значения-аргументы

    Например:
def func(param1, param2):
    print(f'Example {param1}, {param2}')

func(arg1, arg2)


# 5) Как рекурсивные функции работают в Python?

    Рекурсивная функция - это функция, которая способна вызывать себя из себя же, но с иными значениями параметров.
    При этом есть требования для корректной работы рекурсивной функции:
    1) базовый случай
       Обязательно необходимо задать четкое стоп-условие, которое остановит процесс
       и не даст ему выполняться бесконечно
    2) рекурсия
       Чтобы базовый случай в принципе состоялся, требуется передача измененных данных каждой новой вызванной функции

    Например:
def summa(n):
    if n == 1:
        return 1
    else:
        return n + summa(n-1)

summa(5)

# 6) Что такое декораторы функций и как они используются? ( привести свой пример декоратора)

    Декораторы — это функции, которые принимают другую функцию в качестве аргумента,
    добавляют к ней некоторую дополнительную функциональность и возвращают функцию с измененным поведением.

    Декораторы используются, чтобы изменять работу существующих функций или классов,
    добавлять новые возможности и обеспечивать безопасность.

import time

def timer(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"Время выполнения функции {func.__name__}: {end_time - start_time} сек.")
        return result
    return wrapper

@timer
def some_function():
    time.sleep(2)

some_function()

# 7) Как расшифровывается ООП?

    Объектно - ориентированное программирование

# 8) Что относится к основным принципам(парадигмам) ООП?

    - Инкапсуляция: объединение данных и методов, которые работают с этими данными,
      в одном классе и скрытие их от остального кода.
    - Наследование: возможность создавать новые классы на основе уже существующих и наследовать их свойства и методы.
    - Полиморфизм: возможность объектов с одинаковым интерфейсом иметь разные реализации методов.
    - Абстракция: создание упрощенной модели объекта, которая позволяет сосредоточиться на основных характеристиках
      объекта, игнорируя мелкие детали. Абстракция позволяет разрабатывать более гибкие и масштабируемые программы.
    - Композиция: создание нового объекта путем объединения уже существующих объектов.
      Композиция позволяет создавать объекты, которые могут выполнять сложные задачи,
      используя функциональность других объектов.

# 9) Что будет результатом программы и почему?
class Test:
    test = None


print(Test.test)

    Результатом будет None. Т.к. в классе Test мы создали атрибут test и задали ему значение None.
    Затем мы обратились к этому значению через Test.test. Вызывать программу нет необходимости,
    т.к. мы не запрашиваем выполнить какую-то логику
#
# 10) Какой принцип ООП описывает следующее предложение? Этот принцип является способностью использовать
# общий интерфейс для нескольких форм (типов данных).

    Полиморфизм

# 11) Какой из перечисленных вариантов является верным объявлением private поля?
#     private field = 0
#     field = 0
#     _field = 0
#     __field = 0

    __field = 0

# 12) Как создать конструктор класса?

    Метод __init __() имитирует конструктор класса. Этот метод вызывается при создании экземпляра класса.
    Он принимает ключевое слово self в качестве первого аргумента, который позволяет получить доступ к атрибутам или
    методу класса. Мы можем передать любое количество аргументов во время создания объекта класса,
    в зависимости от определения __init __(). В основном он используется для инициализации атрибутов класса

# 13) Как много конструкторов в классе может иметь Python?

    В одном классе может быть неограниченное количество конструкторов и
    сам интерпретатор будет понимать к какому конструктору вы обращаетесь

# 14) Что будет результатом данной программы
# class Test:
#     def print_text(self):
#         print('Это родительский класс Test')
#
# class Test2(Test):
#     def print_text(self):
#         print('Это класс потомок Test2')
#
#
# test = Test2()
# test.print_text()

    --> Это класс потомок Test2

# 15) Какой параметр обязательно принимает в себя метод экземпляра?
#     - тип объекта
#     - сам экземпляр класса
#     - название класса
#     - таких аргументов нет

    - сам экземпляр класса, с помощью параметра self.

# 16) Как использовать инкапсуляцию для защиты данных в классах?

    Инкапсуляцию применяют в названии переменной.
    Есть 3 способа использования инкапсуляции:
    - публичный (public, нет особого синтаксиса, public)
    - защищенный (protected, одно нижнее подчеркивание в начале названия, _protected)
    - приватный (private, два нижних подчеркивания в начала названия, __private)


# 17) Какая разница между абстрактными классами и интерфейсами в Python?

    Разница интерфейса и абстрактного класса в том, что интерфейс не содержит реализации,
    а абстрактный класс может помимо абстрактных методов содержать и часть реализованных методов.

# 18) Как показать в классе что метод является абстрактым?

    abc.abstractmethod – декоратор, который указывает, что метод является абстрактным.
    Этот декоратор применяется к методу внутри абстрактного класса.
    Класс, который наследует свойства и методы от абстрактного класса,
    должен реализовать все абстрактные методы, иначе он также будет считаться абстрактным.

# 19) Что будет результатом программы?
# class Test:
#     __test = 0
#
#
# print(Test.__test)

Результатом будет ошибка, т.к. переменная является приватной
#
# 20) Что делает финализатор класса?

    Пока на какой-либо объект ведет хотя бы одна внешняя ссылка, то он считается используемым и сохраняется в памяти.
    Как только все внешние ссылки пропадают, то сборщик мусора (финализатор) его уничтожает
    (освобождает память, которую он занимал).

# 21) Распишите работу магических методов: new, call

    __new__(cls[, ...]) — метод создания типа класса. Он принимает первым аргументом тип класса,
    в котором он вызывается, и, как правило, возвращает этот же тип. В основном используется,
    чтобы настраивать создание экземпляра класса тех объектов,
    которые наследуются от неизменяемых типов (например, int, str, или tuple)

    Метод __call__ позволяет создавать вызываемый объект, а не функцию. Характеризуя метод __call__ внутри класса,
    создаются вхождения этого класса, которые будут выполнять аналогичные функции при вызове.
    Этот метод обычно вызывается, когда объект вызывается внутри события, в котором он был функцией.

# 22) Если в классе определены два метода с одинаковыми именами и разными списками параметров, что будет результатом?

    Если в классе есть два метода с одинаковыми именами‚ то второе определение полностью заменит первое.
    При вызове этого метода будет использоваться второе определение с соответствующими параметрами.

# 23) Значением поля класса по умолчанию может являться?
#     - значение переменной
#     - константа
#     - результат вызова функции
#     - возможность указания значений полей по умолчанию в Python не предусмотрена

    значение переменной

# 24) Укажите результат выполнения скрипта и почему:
# class Foo:
#     count = x
#     def __init__(self):
#         self.count += 1
#
#     def __del(self):
#         self.count += 1
#
#
# obj = Foo()
# print(obj.count)

    --> NameError: name 'x' is not defined
    К count мы передаём значение х, которое мы нигде не объявили. Поэтому программа выдаст ошибку,
    что не находит значение х
#
# 25) Как указать в программе что класс A наследуется от B?

наследование указывается в круглых скобках после названия класса, который наследует

class A(B):
    тело кода
